## Основи операційного керування процесами в Unix-подібних ОС
### 2.1 Перегляд таблиці процесів

<img width="748" height="984" alt="image" src="https://github.com/user-attachments/assets/d62e9686-e9de-48c7-bba9-a7cb892f2c64" />

 Рис. 1 - фрагмент екрану з рішенням завдання 2.1.1 "Отримати ієрархію процесів у вигляді дерева процесів, враховуючи наступне:
- імена користувачів, які запустили процеси;
- PID процесів."

<img width="513" height="957" alt="image" src="https://github.com/user-attachments/assets/d8d00dd2-213b-4883-8ca1-34a9a9c57b85" />

Рис. 2 - фрагмент екрану з рішенням завдання 2.1.2 "Отримати на екран назви запущених процесів ОС, враховуючи, що, ймовірно, вони можуть бути процесами-даймонами"

<img width="989" height="120" alt="image" src="https://github.com/user-attachments/assets/8b9fccb3-365e-4658-8caf-12d647813013" />

Рис. 3 - фрагмент екрану з рішенням завдання 2.1.3 "Отримати таблицю процесів, враховуючи наступне:
- процеси запущені від імені вашого користувача;
- таблиця процесів має розширений набір стовпчиків;
- для першого рядка опису процесу визначити значення Virtual memory size та Resident memory size"

<img width="645" height="66" alt="image" src="https://github.com/user-attachments/assets/0cf7b77a-b107-45d7-b7d8-4e04e148a813" />

Рис. 4 - фрагмент екрану з рішенням завдання 2.1.4 "Отримати таблицю процесів, враховуючи наступне:
- процес є запущенною bash-оболонкою;
- таблиця процесів містить лише стовпчики: TTY, USER, PID, STIME, CMD"

<img width="921" height="646" alt="image" src="https://github.com/user-attachments/assets/189a65cf-adcf-44b0-91c1-400791ec9118" />

Рис. 5 - фрагмент екрану з рішенням завдання 2.1.5 "Отримати таблицю процесів, враховуючи наступне:
- процеси знаходяться у стані сну;
- процеси не мають псевдотерміналу;
- таблиця процесів містить лише стовпчики: PID, CMD"

<img width="785" height="965" alt="image" src="https://github.com/user-attachments/assets/fa53fe93-325a-45d0-a805-f2e2f71256bf" />

Рис. 6 - фрагмент екрану з рішенням завдання 2.1.6 "Використовуючи команду TOP, отримати список процесів, відсортованих за %
використання оперативної пам’яті"
### 2.2 Керування станами процесів

<img width="700" height="329" alt="image" src="https://github.com/user-attachments/assets/4e52fe04-6d80-487c-80f7-28e6f0d40f4a" />

Рис. 7 - фрагмент екрану з рішенням завдання 2.2.1 "У поточному (1-му) псевдотерміналі виконати команду ping localhost у фоновому режимі"

<img width="1113" height="394" alt="image" src="https://github.com/user-attachments/assets/da8247b7-4f8a-4ae8-a470-6e520052e584" />

Рис. 8 - фрагмент екрану з рiшенням завдання "2.2.2 Запустити 2-й псевдотермінал роботи з Linux-сервером.
У 2-му псевдотерміналі:
- для команди ping отримати таблицю її процесу (стовпчики PID, STAT, CMD);
- призупинити виконання процесу команди ping;
- отримати таблицю процесу команди ping;
- відновити виконання призупиненого процесу ping.
- остаточно завершити роботу процесу команди ping."


<img width="914" height="220" alt="image" src="https://github.com/user-attachments/assets/60206752-c507-4e0b-ada5-c6c2d2aaa847" />

Рис. 9 - фрагмент екрану з рiшенням завдання "2.2.3 У 1-му псевдотерміналі запустити команду ping у режимі «background without
hanging up».
У другому псевдотерміналі для команди ping отримати таблицю її процесу
(стовпчики PID, PPID, STAT, CMD)."

<img width="902" height="415" alt="image" src="https://github.com/user-attachments/assets/858aae90-213e-4692-91a4-050b9755bb46" />

### Висновок: ми бачимо, що через виконані команди, PPID (або ідентифікатор батьківського процесу) команди ping змінився із значення 404441 на 1.

Рис. 10 - фрагмент екрану з рiшенням завдання "2.2.4 Закрити перший псевдотермінал.
У другому псевдотерміналі для команди ping отримати таблицю її процесу
(стовпчики PID, PPID, STAT, CMD).
Порівняти зміст таблиці процесу з пунктом 2.2.3 та зробити висновок про стан
процесу та його новий parent-процес."

<img width="911" height="139" alt="image" src="https://github.com/user-attachments/assets/ed5b96ec-9ec3-4a7c-9e1c-9e6fa9eccb18" />

Рис. 11 - фрагмент екрану з рiшенням завдання "2.2.11 Завершити роботу процесу команди ping."


### 2.3 Керування пріоритетами виконання процесів

<img width="946" height="376" alt="image" src="https://github.com/user-attachments/assets/f913fd70-b9f2-4106-a167-25b6d86cf220" />

Рис. 12 - фрагмент екрану з рiшенням завдання "2.3.1 Створити скрипт-файл на мові програмування bash, який виконує операцію
безкінечного циклічного складання за формулою: x = x + n, де початкове значення х =
номер вашого варіанту, значення n - номер вашого варіанту. Назва файлу збігається з
транслітерацією вашого прізвища із розширенням .sh, наприклад, blazhko.sh
Надати скрипт-файлу права на виконання та запустити його у фоновому режимі."

<img width="960" height="133" alt="image" src="https://github.com/user-attachments/assets/04781eee-86f3-4142-a769-0db25588420d" />

### Висновок: після того як ми запустили tkachenko.sh у фоновому режимі, можна  зробити висновок, що процес був запущений і виконується, використовуючи певну частину процесора.

Рис. 13 - фрагмент екрану з рiшенням завдання "2.3.2 Переглянути таблицю процесів для процесу, пов'язаного із запущеним
скрипт-файлом із урахуванням набору стовпчиків: PID, PPID, STAT, NI,% CPU, CMD.
Зробити висновки про стан процесу запущеного скрипт-файлу та завантаженість
процесору."

<img width="965" height="268" alt="image" src="https://github.com/user-attachments/assets/35953a46-cd32-4cd0-a30d-098e913a42a1" />

### Висновок: після того як ми призупинили роботу скрипт-файлу, ми побачили, що навантаження на процесор почало спадати.

Рис. 14 - фрагмент екрану з рiшенням завдання "2.3.3 Виконати команду призупинення процесу, запущеного у пункті 2.3.1.
Ще раз переглянути таблицю процесів для призупиненого процесу.
Зробити висновки про зміни стану процесу та завантаженості процесору."

<img width="1040" height="91" alt="image" src="https://github.com/user-attachments/assets/d41c5339-ce68-447c-825d-026e9655f1d7" />

### Висновок: якщо порівняти цей пукт із попереднім, то ми бачимо що навантаження на процесор стало ще менше, ніж було.

Рис. 15 - фрагмент екрану з рiшенням завдання "2.3.4 Повторити попереднє завдання, запустивши команду ps із затримкою не
менше 1 хвилини, наприклад, через командний ланцюжок sleep 1m ; ps ...
Порівняти значення завантаженості процесору із результатом попереднього
завдання та зробити відповідний висновок."

<img width="1035" height="166" alt="image" src="https://github.com/user-attachments/assets/3ef31f9e-7e4f-44d1-815c-5dc72a35dda8" />

### Висновок: після відновлення нашого скрипт-файлу ми бачимо, що навантаження на процесор вже почало зростати.

Рис. 16 - фрагмент екрану з рiшенням завдання "2.3.5 Відновити роботу призупиненого процесу.
Ще раз переглянути таблицю процесів для процесу.
Зробити висновки про стан процесу."

<img width="738" height="151" alt="image" src="https://github.com/user-attachments/assets/542b3b10-1ff4-4c1d-a99f-aba719d81e1c" />

Рис. 17 - фрагмент екрану з рiшенням завдання "2.3.6 Cтворити два файли як символічні зв’язки на створений скрипт-файл із
іменами як імена поточного файлу з додаванням цифр 2 і 3, відповідно, наприклад:
blazhko2.sh, blazhko3.sh"

<img width="576" height="245" alt="image" src="https://github.com/user-attachments/assets/17dbe764-950b-4dc9-afa3-ed8b93bc4ade" />

Рис. 18 - фрагмент екрану з рiшенням завдання "2.3.7 Створити скрипт-файл на мові програмування bash, який:
a) запускає два створені скрипт-файли у фоновому режимі;
b) перед запуском кожного скрипт-файлу вказується затримка n секунд, де
значення n – номер вашого варіанту;
c) для кожного скрипт-файлу встановлюється пріоритет процесу, який буде на 10
пунктів нижче ніж пріоритет поточного процесу bash-оболонки."

<img width="931" height="640" alt="image" src="https://github.com/user-attachments/assets/d1421f67-99e2-4465-bcfa-1e3a7f945671" />

### Висновок: після того як ми запустили скрипт-файл можна зробити висновок, що навантаження на процесор відрізняються. tkachenko.sh має навантаження на процесор 27.2%, а ось файли tkachenko2.sh та tkachenko3.sh мають навантаження 2.8%, бо пріоритет нижчий за tkachenko.sh на 10.

Рис. 19 - фрагмент екрану з рiшенням завдання "2.3.8 Запустити файл-скрипт, створений у попередньому пункті.
Переглянути таблицю процесів для трьох запущених процесів.
Зробити висновки за поточними значеннями NI та %CPU."

<img width="940" height="811" alt="image" src="https://github.com/user-attachments/assets/a143b795-682f-4be5-88e8-cd00ece8da70" />

### Висновок: ми змінили пріорітет процесу, пов’язаного з першим скрипт-файлом і бачимо, що навантаження на процесор змінилося. Навантаження tkachenko.sh почало знижуватись, бо був заданний пріоритет 9 для tkachenko.sh. Для tkachenko2.sh та tkachenko3.sh зміни трохи відбулись - навантаження збільшилось до 2.9% та поступово буде збільшуватись приблизно до 3.5%.

Рис. 20 - фрагмент екрану з рiшенням завдання "2.3.9 Зменшити на 9 пунктів пріоритет процесу, пов’язаного з першим файлом.
Переглянути таблицю процесів для трьох запущених процесів.
Зробити висновки щодо змін значень% CPU для кожного процесу: як вони
змінилися?"

<img width="934" height="1020" alt="image" src="https://github.com/user-attachments/assets/92ca739c-3591-4590-9e5a-77e54228808c" />

### Висновок: Якщо порівнювати отриманні значення з пунктом 2.3.8, то можна побачити, що навантаження процесору у топі від скрипт-файлу tkachenko.sh становить 7.6%, а скрипт-файли tkachenko2.sh та tkachenko3.sh мають навантаження 4.3%.

Рис. 21 - фрагмент екрану з рiшенням завдання "2.3.10 Переглянути таблицю процесів для трьох скрипт-файлів через команду top.
Порівняти отримані значення %CPU зі значеннями, які були отримані у
попередньому пункті завдання та надати висновки за результатом порівняння."

<img width="845" height="872" alt="image" src="https://github.com/user-attachments/assets/a8f4dd95-215c-497e-9c8f-23cb9d0defb1" />

Рис. 22 - фрагмент екрану з рiшенням завдання "2.3.11 Завершити роботу трьох запущених процесів."
 
